//hello world this something i make
//perchance.org/unsafeimagesgenerator
//perchance.org/unsafeimages-lite

// Special thanks for something that impossible for me to figure out myself
// search gallery to https://perchance.org/prompt-hunter
// for not using t21 -> beautiful-people there are on pin of course i look at them i dont know who start this sooo...ü´∞
// for comment that go to everywhere -> Kiera 
generateImage = {import:6cqrqp5gvf}
generatorStats = {import:generator-stats-plugin}
aimake = {import:ai-text-plugin}
c0 = {import:unsafe-settings-1}
c1 = {import:unsafe-settings-1}
generateText = {import:ai-text-plugin}
date = {import:date-plugin} 
favicon = {import:favicon-plugin}
iframe = {import:iframe-plugin}
image = {import:6cqrqp5gvf}
commentsPlugin = {import:comments-plugin}
url = {import:url-params-plugin}
ai = {import:ai-text-plugin}
fullscreenButton = {import:fullscreen-button-plugin}
tooltip = {import:tooltip-plugin}
Kiera = {import:yv49wuj5d6}
speak = {import:text-to-speech-plugin} // change the voice, speed, pitch etc. - see the plugin page: https://perchance.org/text-to-speech-plugin
literal = {import:literal-plugin}
tabbedCommentsPlugin = {import:tabbed-comments-plugin-v1}
combineEmojis = {import:combine-emojis-plugin}
remember = {import:unsafe-rememberchange}
gallery1 = {import:unsafe-private-gallery}
superFetch = {import:super-fetch-plugin}



backgroundImage = {import:background-image-plugin}
unsafe = {import:unsafelist}
upload = {import:upload-plugin}

fantasyCharacterPrompt
  instruction
    
    please make short and concise, but detailed description about subject, with a focus on the character's appearance, outfit, and personality. The character should be unique and interesting, with a strong visual identity. The description should be detailed and vivid, allowing the reader to easily imagine the character in their mind. The character should be described in a way that make subject itself is masterpiece in appearance. 
    Design notes:
    [customFeaturesEl.value.trim() || "Subject should have appareance of main character of a story"] // if they don't specify any custom features, then we just give the AI a random race to go with (otherwise it *really* like choosing elves for some reason)
    \n // this just adds an extra newline between the above text and the template below
    Use this HTML formatting template to make it look nice:
    <b>Name:</b> Name of {Race|Creature|Alien|Fantasy Character}.
    <b>{Race|Creature|Alien|Fantasy Character}:</b> ___. // NOTE: If you change this first item in the template, make sure you change the 'startWith = ...' setting below, to match it!
    <b>{Outfit|Skin|Outfit and Skin}:</b> ___.
    <b>Face:</b> ___.
    <b>Body Shape:</b> ___.
    <b>Hairstyle:</b> ___.
    <b>{Special Body feature|anything}:</b> ___.
    <b>Profession:</b> ___.
    <b>{Weapon|Tool|Accessories}:</b> ___.
    
    !important: don't start this instruction if you just created the subject, subject you created is real person that have life and desire. if you asked to continue please think longer to make record in novel format of subject activity and subject response to various encounter with other character within "___" example: "what do you want?" she ask, make the record fit subject appareance you have created, you are free to make any kind of activity and conversation subject would have make.
    <b>Encounter:</b> \n ___.
    !important please continue subject encounter story.
    $output = [this.joinItems("\n")]
  
  startWith = <b>Name:</b> // <-- we force the AI to start with "<b>Race:</b>" just to make sure it properly uses the HTML formatting, and to ensure it doesn't start with "Sure, I can help with that" or whatever. Make sure this matches up with the first item in the instruction template, above.
  
  //onStart(data) => // runs when the 'regenerate' button is pressed
    generateBtnCD.disabled = false;
    imageEl.innerHTML = ""; // clear the previous image, if any
  //async onFinish(data) =>
    generateBtnCD.disabled = false;
    let generatedText = data.text;
    let textToBeSummarized = generatedText.replaceAll("<b>", "").replaceAll("</b>", "").replaceAll("\n", " -- "); // we remove the HTML <b> tags and replace newlines with "---"
  //  let summaryPrompt = {
      instruction: `Below is a description of a character. Please turn it into a comma-separated list of descriptive keywords which visually capture this character.\n---\n${textToBeSummarized}\n---\nReply with a comma-separated list of keywords and keyphrases which *visually* capture the above character. Imagine you're giving a list of keywords to an artist who will use them to draw the character. Describe the character's appearance with keywords/keyphrases, including their race, class, age, etc. Respond with only the comma-separated keyphrases - nothing more, nothing less.`, // I basically repeat the instruction a few times for good measure.
  //  };
   // let obj = ai(summaryPrompt);
    imageEl.innerHTML += obj.loadingIndicatorHtml; // <-- the plugin gives us handy way to add the loading indicator to the page in situations like this
    let responseData = await obj.onFinishPromise; // <-- this "waits" at this line until the AI is finished, and then gives us the same data that we'd get via the onFinish handler. we are "awaiting" a JavaScript "Promise" (you can ask ChatGPT to explain it to you)

  //  let promptData = {
      prompt: "aesthetically pleasing with everything positioned perfectly, impeccable attention to detail,best quality, highly detailed, sharp focus, 8k, 4k, crisp edges, refined details, perfect composition, depth of field, cinematic lighting, vibrant colors, award-winning style, professional quality, flawless depiction."+responseData,
      negativePrompt: "",
      resolution: "512x768",
   // };
    let imageHtml = "";
   // for (let i = 0; i < 4; i++) {
    imageHtml += `
      <div class\="imageWrapper" style\="display:flex; flex-direction:column; align-items:center; justify-content:center; margin:1rem auto; max-width:86%;">
      <div style\="width:100%; display:flex; justify-content:center;">
 //     ${image(promptData).evaluateItem}
    </div>
  //  </div>`;}

    imageEl.innerHTML = `
    <div style\="text-align:center; max-width:86%; margin:0 auto;">
    <b>Image Prompt:</b> 
   // <span id="responseText">${responseData.text}</span>
    <button 
      onclick="navigator.clipboard.writeText(document.getElementById('responseText').innerText)" 
      style="margin-left:10px;padding:3px 8px;border-radius:6px;border:1px solid #ccc;cursor:pointer;background:#f3f3f3;">
      üìã Copy
    </button>
    <br><br>
  //  ${imageHtml}
    </div>`;
fantasyCharacterPromptoutput
  [ai(fantasyCharacterPrompt)]

  
settings
  instruction() => 
    return instructionEl.value;
  startWith() => 
    return responseEl.value;
  outputTo = [responseEl]  
  onStart() =>
    generateBtn.disabled = true;
    continueBtn.disabled = true;
  onFinish() =>
    generateBtn.disabled = false;
    continueBtn.disabled = false;
BadGPT
  [ai(settings)]







  

galleryOptions
  gallery = true
  sort = [sortunsafe.value.trim()||recent]
  contentFilter = none
  adaptiveHeight = true
  hideIfScoreIsBelow = [voteunsafe.value.trim()||-3]
  style = background: rgba(30, 30, 30, 0.8); border: 4px solid rgba(255, 255, 255, 0.15); border-radius: 16px;
  bannedUsers = [unsafe.gallery] 
  bannedPromptPhrases = [unsafe.prompt]
  bannedNegativePromptPhrases = [unsafe.negative]
  customButton
    emoji = ü•ï
    onClick(data) =>
      let oldModal = document.getElementById("galleryModal")
      if (oldModal) oldModal.remove()

      let modal = document.createElement("div")
      modal.id = "galleryModal"
      Object.assign(modal.style, {
        position: "fixed",
        inset: "0",
        background: "rgba(0,0,0,0.7)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        zIndex: "9999"
      })

      let content = document.createElement("div")
      Object.assign(content.style, {
        background: "#1e1e1e",
        borderRadius: "12px",
        padding: "20px",
        color: "#fff",
        minWidth: "250px",
        textAlign: "center",
        boxShadow: "0 4px 20px rgba(0,0,0,0.4)"
      })

      function makeBtn(label, action, closeAfter = true) {
        let btn = document.createElement("button")
        btn.textContent = label
        Object.assign(btn.style, {
          display: "block",
          width: "100%",
          margin: "8px 0",
          padding: "10px",
          border: "none",
          borderRadius: "8px",
          background: "#333",
          color: "white",
          fontSize: "15px",
          cursor: "pointer"
        })
        btn.onmouseover = () => btn.style.background = "#555"
        btn.onmouseout  = () => btn.style.background = "#333"
        btn.onclick = () => {
          action()
          if (closeAfter) modal.remove()
        }
        return btn
      }

      // Add action buttons
      content.appendChild(makeBtn("üñº Fullscreen", () => showImageFullscreen(data.imageUrl)))
      content.appendChild(makeBtn("‚¨á Download", async () => {
        try {
        if (!data.imageUrl) {
        alert("No image URL available to download.");
        return;
        }

        // Fetch image as blob
        let response = await fetch(data.imageUrl);
        let blob = await response.blob();

         // Create download link
        let url = URL.createObjectURL(blob);
        let a = document.createElement("a");
        let seed = data.seed ? "_seed" + data.seed : "";
        a.download = "image" + seed + ".png";
        a.href = url;
 
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        } catch (err) {
        console.error("Download failed:", err);
        alert("Failed to download image.");
        }
        }));   
      
      content.appendChild(makeBtn("üîó Copy Prompt", async () => {
        if (data.prompt) {
          await navigator.clipboard.writeText(data.prompt)
          alert("Prompt copied!")
        } else {
          alert("No prompt available for this image.")
        }
      }, false))
      content.appendChild(makeBtn("‚úè Edit & Regenerate", () => {
        if (data.prompt) {
          document.getElementById("output").value = data.prompt
          genimgsperfectX()
        } else {
          alert("No prompt available to regenerate.")
        }
      }))
      content.appendChild(makeBtn("üì§ Share Image", async () => {
        if (!data.imageUrl) return alert("No image to share.")
        try {
        let shareText = (data.prompt ? data.prompt + "\n\n" : "") + "Generated using: https://perchance.org/unsafeimagesgenerator"

        if (navigator.share) {
        await navigator.share({
          title: "Shared Image",
          text: shareText,
          url: data.imageUrl
        })
        } else {
        await navigator.clipboard.writeText(data.imageUrl + "\n\n" + shareText)
          alert("Image URL and generator link copied to clipboard!")
          }
          } catch (err) {
          console.error("Share failed:", err)
          alert("Could not share image.")
        }
        }))
      content.appendChild(makeBtn("üó®Ô∏è Create Character", () => {
        window.UAIC_AUTO_FROM_PROMPT = data.prompt || ""; // store prompt
        showCreateCharacterForm();
        }, false));
      content.appendChild(makeBtn("‚ùå Close", () => {}, true))

      modal.appendChild(content)
      try {
      let fsTarget = document.fullscreenElement;
      if (!fsTarget || fsTarget === document.body || fsTarget === document.documentElement) {
      document.body.appendChild(modal);
      } else {
      fsTarget.appendChild(modal);
      }
      } catch (err) {
      console.error("Modal append failed:", err);
      document.body.appendChild(modal);
      }
  customButton2
    emoji = üõ°Ô∏è
    onClick(data) =>
      ;(async function () {
        try {
          // Fetch image blob
          const response = await fetch(data.imageUrl);
          const blob = await response.blob();

          // Add to active folder with metadata
          await gallery1.add(blob, {
            info: {
              prompt: String(data.prompt ?? ""),
              negativePrompt: String(data.negativePrompt ?? ""),
              seed: String(data.seed ?? ""),
              guidanceScale: String(data.guidanceScale ?? "")
            }
          });

          animateThumbnailToCorner(data.imageUrl);
        } catch (err) {
          alert("‚ùå Failed: " + err.message);
        }
      })()                            
                                                                
                                                                
                                                                
showImageFullscreen(imageUrl) =>
  let overlay = document.createElement('div');
  overlay.style.cssText = `position:fixed; inset:0; display:flex; justify-content:center; align-items:center; background:rgba(0,0,0,.8); z-index:9999`;
  document.body.appendChild(overlay);

  let img = new Image();
  img.src = imageUrl;
  img.style.cssText = 'max-width:100%; max-height:100%; box-shadow:0 0 20px #000';

  let close = document.createElement('div');
  close.textContent = '‚úñ';
  close.style.cssText = `position:absolute; top:12px; right:16px; font:32px/1 sans-serif; color:#fff; cursor:pointer`;

  let remove = ()=>overlay.remove();
  overlay.onclick = e => (e.target===overlay) && remove();
  close.onclick = remove;

  overlay.append(img, close);



  
  
  
  
$meta
  title = Unsafe Images
  description = Create stunning and imaginative AI images instantly. No filters, no restrictions ‚Äì just endless creativity with this powerful free AI image generator, chat, image to image, image to video, story, character creator.
  image = https://user.uploads.dev/file/2f3d2a55d77eaa9c855b6fb1b9864b3b.jpg
  header 
    background = linear-gradient(to bottom, #88b4ff, #4d75b8)
    mode = minimal
title
  Unsafe Images 


storyWritingPrompt
  instruction
    Your task is to write the [storySoFarEl.value.trim() ? "next" : "first"] part of an award-winning story. Don't wrap it up! Don't rush! [storySoFarEl.value.trim() ? "Just write 4 more paragraphs." : "Just write the first 4 paragraphs. Do NOT foreshadow or hint at what is going to happen. Lead into the story from an **unexpected** and creative angle."] Create an engaging, captivating, and genuinely fascinating story - so good that you can't stop reading. Aim for superb narrative pacing and fascinating worldbuilding. Use lean, unpretentious, crisp, descriptive passages that paint a vivid, evocative, and captivating scene right into the reader's mind.
    [whatHappensNextEl.value.trim() ? "IMPORTANT: The first two or three paragraphs that you write MUST be based on this instruction/idea: **"+literal(whatHappensNextEl.value.trim())+"**" : ""]
    # Overall, here's what the story is about[storySoFarEl.value.trim().length < 1000 ? " (but don't start with this! lead in slowly)" : ""]:
    [storyOverviewEl.value.trim() || "(Unsure, you decide.)"]
    \n\n
    # Here's what has happened so far:
    // Note: below, we leave off the last paragraph because it'll be put in the startWith text
    [literal(window.preprocessedStorySoFarText.trim().split("\n\n").slice(0, -1).join("\n\n").trim() || "(Nothing yet.)")] // include all but the last paragraph, since we put the last paragraph in `startWith`
    \n\n
    Write the [storySoFarEl.value.trim() == "" ? "first" : "next"] paragraph of this story based on the above instruction. You are to write four more paragraphs only. No more, no less.
    [""]
    # Reminders:
    - NEVER try to "wrap up" the story. Avoid repetitive and cliche or hackneyed phrases. Avoid excessive and pretentious 'purple prose'. NEVER repeat earlier events.
    - In general, try to stay in the present moment and explore it extensively. Never rush to finish a scene. Take it slow, and explore the present moment with vivid, grounded, and riveting explorations of the current situation.
    - Show, don't tell. In other words, don't boringly "tell" the reader things directly. This isn't a summary. Instead, let them slowly work out what's going on from the clues you leave in dialogue, character behavior, descriptions, etc.
    - Your writing should be interesting, authentic, vividly descriptive, engaging, logically coherent, and delightfully creative.
    - [storySoFarEl.value.trim() ? "" : `Start the story in an unusual and interesting way. Lead into it from an unexpected angle. `]Don't be predictable and boring. The quality of your writing should be comparable to that of a world‚Äìrenowned, award-winning author. Original, subtle, engaging, authentic, grounded, nuanced.
    [whatHappensNextEl.value.trim() ? "\nIMPORTANT: Remember, the first two or three paragraphs that you write MUST be a creative interpretation of this instruction/idea: **"+literal(whatHappensNextEl.value.trim())+"**" : ""]
    // leave the below line unedited (it joins the above lines into one block of text)
    $output = [this.joinItems("\n")] 
  
  startWith = [literal(getStartWithText())] // put last paragraph in `startWith`
  
  // CAUTION: note to self: if you change the stop sequence, ensure that the onChunk new-line removal stuff still makes sense
  stopSequences = [oneParagraphAtATimeCheckbox.checked ? ["\n\n"] : []] 
  
  onStart(data) => // runs when the 'regenerate' button is pressed
    window.gotFirstChunk = false;
    window.temporarilyRemovedPrefixForStreamingRenderPerformance = null;
    storySoFarEl.scrollTop = 99999999;
    generateBtn.disabled = true;
    regenLastBtn.disabled = true;
    deleteLastBtn.disabled = true;
    generateBtn.textContent = "‚åõ loading...";
    stopBtn.style.display = "block";
  onChunk(data) =>      
    if(data.isFromStartWith) {
      // we don't put the startWith text into the textarea because it's already there
    } else {
      let textChunk = data.textChunk;
      if(!window.gotFirstChunk) {
        // this is a performance optimization for when story gets really long - we reomve some text from the start and add it back after, otherwise page gets laggy as response streams in.
        if(storySoFarEl.value.length > 50000) {
          let prevPageScrollTop = document.scrollingElement.scrollTop;
          window.temporarilyRemovedPrefixForStreamingRenderPerformance = storySoFarEl.value.slice(0, -50000)
          storySoFarEl.value = storySoFarEl.value.slice(-50000);
          document.scrollingElement.scrollTop = prevPageScrollTop;
        }
        if(textChunk.startsWith("\n") && storySoFarEl.value.endsWith("\n\n")) {
          textChunk = textChunk.replace(/^\n+/g, "");
        }
      }
      window.gotFirstChunk = true;
      
      // we're manually adding each chunk of generated text to the "storySoFarEl" text box, rather than using `outputTo`, since `outputTo` would clear all the existing text and only add the *response*, whereas we want to preserve all the existing text, and just add the response to the end. 
      if(oneParagraphAtATimeCheckbox.checked) {
        storySoFarEl.value += textChunk.replace(/\n\n$/g, ""); // don't add trailing newlines - to prevent "scroll jank" in onFinish when we trim() the story
      } else {
        storySoFarEl.value += textChunk; 
      }
    }
    if(storySoFarEl.scrollTop > (storySoFarEl.scrollHeight - storySoFarEl.offsetHeight)-30) { // <-- if the text box is already scrolled near the end of the text
      storySoFarEl.scrollTop = 99999999; // scroll down to bottom of text box as story streams in
    }
  onFinish(data) =>
    if(window.temporarilyRemovedPrefixForStreamingRenderPerformance) {
      // page scroll messes up when we add prefix back, so we need to save + restore:
      let prevPageScrollTop = document.scrollingElement.scrollTop;
      storySoFarEl.value = window.temporarilyRemovedPrefixForStreamingRenderPerformance + storySoFarEl.value;
      storySoFarEl.scrollTop = 999999999;
      document.scrollingElement.scrollTop = prevPageScrollTop;
      
      window.temporarilyRemovedPrefixForStreamingRenderPerformance = null;
    }
    generateBtn.disabled = false;
    regenLastBtn.disabled = false;
    deleteLastBtn.disabled = false;
    generateBtn.textContent = "‚ñ∂Ô∏è next paragraph";
    stopBtn.style.display = "none";
    storySoFarEl.value = storySoFarEl.value.trim(); // remove newlines and spaces from the end of the story
    localStorage.storySoFar = storySoFarEl.value;
    updateButtonsDisplay();

getStartWithText() => 
  let text = storySoFarEl.value.trim().split("\n\n").slice(-1).join("\n\n").trim();
  if(window.continueMode === "inline") {
    return text;
  } else if(storySoFarEl.value !== "" && /[.?!":¬ª‚Äô‚Äù‚Äî‚Äì]$/.test(storySoFarEl.value.trim())) { // if the story textbox isn't empty and it ends with a fullstop, question mark, quote, etc.
    return text+"\n\n"; // then we add a couple of new lines to the end, ready for the next paragraph that's about to be generated
  } else {
    return text;
  }

async continueStory(opts) =>
  if(window.currentlyGenerating) return; // we already disable buttons below, but this is just for extra safety
  window.currentlyGenerating = true;
  
  try { injectSummariesAndComputeNextSummariesInBackgroundIfNeeded(); } catch(e) { console.error(e); }
  await new Promise(r => setTimeout(r, 5)); // just in case i accidentally make the above function async at some point - want to ensure it grabs a snapshot of the chat logs text before `temporarilyRemovedPrefixChatLogsForStreamingRenderPerformance` stuff
  
  window.userClickedStop = false;
  resetRatingButtons();
  
  continueTextBtn.style.visibility = "hidden"; // using this too because i think the continue button textarea tracking stuff is making it visible during generation via style.display
  continueTextBtn.style.display = "none";
  continueTextBtn.disabled = true;
  
  // important for summary stuff, since we need "normalized" paragraphs so that summary replacements/injections work properly:
  storySoFarEl.value = storySoFarEl.value.split(/\n+/).map(p => p.trim()).join("\n\n");
  
  if(!opts) opts = {};
  if(!opts.continueInline && storySoFarEl.value !== "" && /[.?!":¬ª‚Äô‚Äù‚Äî‚Äì]$/.test(storySoFarEl.value.trim())) { // if the story textbox isn't empty and it ends with a fullstop, question mark, quote, etc.
    storySoFarEl.value = storySoFarEl.value.trim() + "\n\n"; // then we add a couple of new lines to the end, ready for the next paragraph that's about to be generated
  }
  if(opts.continueInline) {
    storySoFarEl.value = storySoFarEl.value.trim();
    window.continueMode = "inline";
  } else {
    window.continueMode = "normal";
  }
  
  window.preprocessedStorySoFarText = storySoFarEl.value;
  try {
    // get a version of the message feed with hierarchical summaries swapped in:
    let messagesWithSummaryReplacements = getMessagesWithSummaryReplacements(storySoFarEl.value);

    if(messagesWithSummaryReplacements.slice(-8).filter(m => /^SUMMARY\^[0-9]+:/.test(m)).length > 0) {
      console.error("Summarization is going too close to the end of the story. Must stay back so LLM doesn't get confused, and so messages-in-startWith trick works.");
    }
    messagesWithSummaryReplacements = messagesWithSummaryReplacements.map(m => m.replace(/SUMMARY\^[0-9]+:/, "Summary (previous events):").trim());

    window.preprocessedStorySoFarText = messagesWithSummaryReplacements.join("\n\n").trim();
  } catch(e) {
    console.error("Falling back to using *all* messages because there was an error while trying to compute messagesWithSummaryReplacements:", e);

    window.preprocessedStorySoFarText = storySoFarEl.value;
  }
  
  window.storyTextBeforeLastGeneration = storySoFarEl.value;
  window.lastGenerationStreamObj = ai(storyWritingPrompt); // we put it into a 'global' variable so that we can use it in the 'onclick' of the stop button to stop the text generation
  let data = await window.lastGenerationStreamObj;
  
  window.currentlyGenerating = false;
  
  if(localStorage.generateCount === undefined || isNaN(Number(localStorage.generateCount))) localStorage.generateCount = "0";
  localStorage.generateCount = Number(localStorage.generateCount) + 1;
  updateLastParagraphButtonsDisplayIfNeeded();
  
  if(data.stopReason !== "error" && !window.userClickedStop) {
    enableRatingButtons();
  }
  
  continueTextBtn.disabled = false;
  continueTextBtn.style.visibility = "visible";
  
  let generateCount = Number(localStorage.generateCount);
  if(generateCount > 20 && !localStorage.haveUsedTabToContinueMessage) {
    let isTouchScreen = false;
    try { isTouchScreen = window.matchMedia("(pointer: coarse)").matches; } catch(e) { console.error(e); }
    if(window.innerWidth > window.innerHeight && !isTouchScreen) {
      continueTextBtnTabLabel.style.display = "";
    }
  }
  if(generateCount > 5) {
    topStuffEl.style.display = "none";
  }

updateLastParagraphButtonsDisplayIfNeeded() =>
  let generateCount = Number(localStorage.generateCount); 
  if(generateCount > 4) {
    rateLastMessageCtn.style.display = "inline-block";
    deleteLastBtn.textContent = "üóëÔ∏è";
    deleteLastBtn.style.minWidth = "3rem";
    deleteLastBtn.style.marginLeft = "1rem";
    regenLastBtn.textContent = "üîÅ";
    regenLastBtn.style.minWidth = "3rem";
  }

updateButtonsDisplay() =>
  if(storySoFarEl.value.trim() === "") {
    bottomButtonsCtn.style.display = "none";
  } else {
    bottomButtonsCtn.style.display = "";
    generateBtn.textContent = "‚ñ∂Ô∏è next paragraph";
  }
  
generateWhatHappensNextIdeas() =>
  whatHappensNextSuggestionsCtn.style.display = "";
  generateWhatHappensNextIdeasBtn.disabled = true;
  
  let textSoFar = "";
  let pendingObj = ai({
    instruction: whatHappensNextInstruction.evaluateItem,
    startWith: `Here are 3 different ideas for what could happen next in this story:\n1.`,
    onChunk: (data) => {
      textSoFar += data.textChunk;
      if(!data.isFromStartWith) {
        whatHappensNextSuggestionsCtn.innerHTML = textSoFar.replace(/\n+/g, "\n\n");
      }
    },
    onFinish: () => {
      let existingInstruction = (window.whatHappensNextSuggestionsRegenInstructions || "").trim().replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      
      let html = textSoFar.trim().split("\n").filter(l => /^[0-9]+\./.test(l.trim())).map(l => l.replace(/^[0-9]+\./g, "").trim()).map(ideaText => {
        let ideaTextEscaped = ideaText.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        return `<div style="border:1px solid gray; margin:0.25rem; display:flex; padding:0.25rem; border-radius:3px;">
          <div style="">${ideaTextEscaped}</div>
          <button data-idea="${ideaTextEscaped}" onclick="whatHappensNextEl.value=this.dataset.idea; whatHappensNextSuggestionsCtn.style.display='none';">use</button>
        </div>`;
      }).join("");
      
      html = `<div style="max-height: min(90vh, 600px); overflow: auto ">${html}</div>`;
      html += `<div style="display:flex; margin:0.25rem;"><input value="${existingInstruction}" oninput="window.whatHappensNextSuggestionsRegenInstructions=this.value" placeholder="(Optional) Idea regen instructions." style="flex-grow: 1;"><button style="margin-left: 0.25rem;" onclick="generateWhatHappensNextIdeas()">üîÅ regen</button></div>`;
      
      whatHappensNextSuggestionsCtn.innerHTML = html;
      generateWhatHappensNextIdeasBtn.disabled = false;
    },
  });
  whatHappensNextSuggestionsCtn.innerHTML = pendingObj.loadingIndicatorHtml;

whatHappensNextInstruction
  Please write 3 *short* one-sentence, creative ideas for what could happen next in this story.
  [window.whatHappensNextSuggestionsRegenInstructions?.trim() ? `IMPORTANT: Your ideas **MUST** be based on this instruction: ${window.whatHappensNextSuggestionsRegenInstructions}` : ""]
  [""]
  [literal(getMessagesWithSummaryReplacements(storySoFarEl.value).join("\n\n").trim())]
  [""]
  Again, please write 3 one-sentence ideas. They should be unique, creative, high-level ideas for what could happen next. Just give a few words for each idea.
  Your ideas should be comparable to that of a world‚Äìrenowned, award-winning author. Original, subtle, realistic, engaging, authentic, grounded, nuanced.
  Each idea must be a SINGLE, *short* sentence.
  [window.whatHappensNextSuggestionsRegenInstructions?.trim() ? `IMPORTANT: Your ideas **MUST** be based on this instruction: ${window.whatHappensNextSuggestionsRegenInstructions}` : ""]
  Follow this template:
  [""]
  1. <a short, **ONE-SENTENCE** spark for an idea about what could happen next>
  2. <a *DIFFERENT* idea for what could happen next>
  3. <another SHORT alternative idea for what could happen next>
  $output = [this.joinItems("\n")]


  
resetRatingButtons() =>
  rateLastMessageBadBtn.disabled = true;
  rateLastMessageGoodBtn.disabled = true;
  rateLastMessageBadBtn.style.opacity = 1;
  rateLastMessageGoodBtn.style.opacity = 1;
  
enableRatingButtons() =>
  rateLastMessageBadBtn.disabled = false;
  rateLastMessageGoodBtn.disabled = false;
  
async rateLastMessage(rating) =>
  if(!window.lastGenerationStreamObj) return;
  
  if(!localStorage.knowsHowRatingsWork) {
    if(!confirm("Your ratings help improve Perchance's AI plugin, which powers this generator. Please do not submit ratings if your story includes sensitive personal info.\n\nContinue?")) return;
    localStorage.knowsHowRatingsWork = "1";
  }
  
  let score = rating==="good" ? 1 : 0;
  rateLastMessageBadBtn.disabled = true;
  rateLastMessageGoodBtn.disabled = true;
  if(rating === "good") {
    rateLastMessageBadBtn.style.opacity = 0.2;
  } else {
    rateLastMessageGoodBtn.style.opacity = 0.2;
  }
  
  if(!window.recentRatingReasonCounts) window.recentRatingReasonCounts = {};
  let reasonCountEntries = Object.entries(window.recentRatingReasonCounts).sort((a,b) => b[1]-a[1]);
  if(reasonCountEntries.length > 10) reasonCountEntries = reasonCountEntries.slice(0, 10);
  window.recentRatingReasonCounts = Object.fromEntries(reasonCountEntries);
  recentRatingReasonsDataList.innerHTML =  reasonCountEntries.map(e => `<option value="${e[0].replace(/</g, "&lt;").replace(/"/g, "&quot;")}"></option>`).join("");
  
  let reasonResolver;
  let reasonFinishPromise = new Promise(r => reasonResolver=r);
  ratingReasonEl.value = "";
  ratingReasonCtn.style.display = "";
  ratingReasonEl.focus();
  await new Promise(r => setTimeout(r, 100));
  
  // if they click anywhere other than the reason input, then we resolve with the current contents of the reason box
  function windowClickHandler(event) {
    if(!ratingReasonCtn.contains(event.target)) {
      reasonResolver(ratingReasonEl.value);
    }
  }
  window.addEventListener("click", windowClickHandler);
  
  // if they press enter, then we resolve too
  function enterKeydownHandler(event) {
    if(event.key === 'Enter') {
      reasonResolver(ratingReasonEl.value);
    }
  }
  ratingReasonEl.addEventListener("keydown", enterKeydownHandler);
  
  let reason = await reasonFinishPromise;
  if(reason.length < 100) window.recentRatingReasonCounts[reason] = (window.recentRatingReasonCounts[reason] || 0) + 1;
  
  ratingReasonCtn.style.display = 'none';
  window.removeEventListener("click", windowClickHandler);
  ratingReasonEl.removeEventListener("keydown", enterKeydownHandler);
  window.lastGenerationStreamObj.submitUserRating({score, reason});

async copyStoryTextToClipboardWithoutSummaries() =>
  let text = storySoFarEl.value.split(/\n+/).map(p => p.trim()).filter(p => !p.startsWith("SUMMARY^")).join("\n\n");
  
  await navigator.clipboard.writeText(text);
  copyStoryTextWithoutSummariesBtn.textContent = "‚úÖ copied";
  setTimeout(() => {
    copyStoryTextWithoutSummariesBtn.textContent = "üìã copy story without summaries";
  }, 3000);


getMessagesWithSummaryReplacements(text, opts) =>
  if(!opts) opts = {};
  const minimumMessageLevel = opts.minimumMessageLevel || 0; // used by the summarization process.
  
  let messages = text.split("\n\n").map(m => m.trim()).filter(m => m);
  let messagesWithSummaryReplacements = [];
  let highestLevelSeen = 0;
  
  // it's we go backwards through the messages, and only 'collect' a message if its level is not below the highest level we've seen so far. it makes sense if you think about it for a bit.
  // said another way, we go from the end of the messages to the start while 'monotonically climbing' up a level whenever we hit a 'higher' message.
  while(messages.length > 0) {
    let m = messages.pop();
    let level = Number((m.match(/SUMMARY\^([0-9]+):/)||[])[1] || 0);
    if(level < minimumMessageLevel) continue;
    if(level >= highestLevelSeen) {
      messagesWithSummaryReplacements.unshift(m);
      highestLevelSeen = level;
    }
  }
  return messagesWithSummaryReplacements;
  

summaryPromptInstruction
  Your task is to generate some text for a story/narration and then a 'SUMMARY' of that text, and then repeat a few times. Below is the story overview, and a summary of earlier events. You must write the text, and then a summary of that text that you wrote, and then some more text, and a summary of that new text, and repeat. Each summary should be a single paragraph of text which concisely compresses the recent text to roughly half its original size.
  IMPORTANT: Every summary must be UNIQUE, and it must be concise, and information dense. Avoid flowery prose in summaries. Write concise summaries, but don't miss any important facts/events.
  IMPORTANT: Summaries must contain ALL important details from the text they're summarizing. Try to include *every* important detail in your summaries, resulting in a summary that is about half the length of the original text.
  Use this format/template for your response:
  ```
  \[A\]: <story/narration text>
  SUMMARY of \[A\]: <a dense, one-paragraph summary of the \[A\] text>
  ---
  \[B\]: <story/narration text>
  SUMMARY of \[B\]: <a dense, one-paragraph summary of the \[B\] text>
  ---
  \[C\]: <story/narration text>
  SUMMARY of \[C\]: <a dense, one-paragraph summary of the \[C\] text>
  ```
  [""]
  # Story Overview:
  [literal(storyOverviewEl.value.trim().replace(/\n+/g, "\n") || "(Not specified.)")]
  [""]
  # Summary of Previous Events:
  [literal(window.summaryMessagesForInstruction.join("\n"))]
  [""]
  ---
  [""]
  Again, your task is to write some text labelled with a letter, and then a summary of that text, and then some new text, and then a summary of that new text, and so on. Each summary should be a single paragraph of text which compresses the new text to roughly half its original length. Don't add flowery prose to summarise. Summary messages should be *dense* with important facts and information. Include *all* the plausibly-relevant story details from the text within the summary.
  IMPORTANT: Each 'SUMMARY' message must be UNIQUE and distinct from previous summaries. And 'SUMMARY of \[C\]' should include ALL important details from the \[C\] text and *never* invent any details that weren't in the text. Avoid accidentally repeating the events/details from earlier messages/summaries.
  IMPORTANT: The summaries must use short, information-dense sentences to compress the text into the key facts. Summaries should concisely capture *all* the *important* points from the text, compressing the text to about half its original length while retaining all important events/details.
  $output = [this.joinItems("\n")] // joins all of the above lines together

// CAUTION: note to self: don't make this async - must synchronously grab chatlog text due to `temporarilyRemovedPrefixChatLogsForStreamingRenderPerformance` stuff changing chat log text during streaming
injectSummariesAndComputeNextSummariesInBackgroundIfNeeded() =>
  if(!window.summariesReadyToInject) window.summariesReadyToInject = [];
  // inject summaries if we have any:
  if(window.summariesReadyToInject.length > 0) {
    // ensure logs are normalized so our message comparison checks work:
    let allMessagesOriginal = storySoFarEl.value.split(/\n+/g).map(m => m.trim()).filter(m => m);
    let allMessagesNew = allMessagesOriginal.slice(0);
    for(let {summarizedMessages, lastMessageSummarizedIndex, summary, level} of window.summariesReadyToInject) {
      let lastSummarizedMessage = summarizedMessages[summarizedMessages.length-1];
      if(allMessagesOriginal[lastMessageSummarizedIndex] === lastSummarizedMessage) {
        allMessagesNew.splice(lastMessageSummarizedIndex + 1, 0, `SUMMARY^${level}: ${summary}`);
      } else {
        console.warn("Content of last-summmarized-message doesn't match content of message at lastMessageSummarizedIndex. Safe to ignore this warning if logs have been edited since last 'send' button click. This summary will simply be discarded and we'll compute a new one with the up-to-date chat logs.");
      }
    }
    storySoFarEl.value = allMessagesNew.join("\n\n");
    window.summariesReadyToInject = [];
  }
  
  const { countTokens, idealMaxContextTokens } = ai({getMetaObject:true});
  
  const contextLengthToIdeallyStayUnder = idealMaxContextTokens*0.88;
  const numCharsToSummarizeAtATime = 1500;// if this is too big, then it takes too many messages to
  
  // must get text synchronously, since storySoFarEl can be temporarily ablated during streaming for rendering performance.
  const storySoFarElText = storySoFarEl.value;
  const messagesWithSummaryReplacements = getMessagesWithSummaryReplacements(storySoFarElText);
  
  let currentlyUsedContextLength = countTokens(messagesWithSummaryReplacements.join("\n\n") + storyOverviewEl.value);
  if(currentlyUsedContextLength < contextLengthToIdeallyStayUnder) {
    console.log(`Summarization not needed. currentlyUsedContextLength=${currentlyUsedContextLength} which is less than ${contextLengthToIdeallyStayUnder}`);
    return;
  }
      
  // compute next summary in background if needed:
  (async function() {
    if(window.alreadyDoingSummary) return;
    try {
      window.alreadyDoingSummary = true;
      
      const allMessageObjs = storySoFarElText.split(/\n+/).map(m => m.trim()).filter(m => m).map((text, i) => {
        return {
          text, // note that this `text` is trimmed in the `map` above - very important that we do this kind of normalization for summary replacement stuff, since we do actual string-match replacement.
          index: i,
          level: Number((text.match(/SUMMARY\^([0-9]+):/)||[])[1] || 0)
        };
      });
      
      // conceptually we treat each "level" just like the first.
      // the first level is just a bunch of messages with interspersed "SUMMARY^1: ..." messages, where the summary messages are a summary of the messages before them, up to the *previous* "SUMMARY^1: ..." message.
      // so for the next level, we just delete/ignore the ^0 messages (i.e. the *actual* messages), and do exactly the same thing - i.e. treat "SUMMARY^1: ..." as if they were "messages" and "SUMMARY^2: ..." are the summaries of those "messages".
      
      let summaryLevelToMessageBlocks = new Map();
      let summaryLevelBeingProcessed = 1;
      while(1) {
        // grab messages that are relevant to this 'level' (i.e. only this level and lower one):
        const thisLevelAndPreviousLevelMessageObjs = allMessageObjs.filter(m => m.level === summaryLevelBeingProcessed || m.level === summaryLevelBeingProcessed-1);
        
        if(thisLevelAndPreviousLevelMessageObjs.length === 0) {
          console.log("Finished creating summaryLevelToMessageBlocks.");
          break;
        }
        
        // get all summary 'blocks' (i.e. groups of messages ending with a summary message of this `level` that summarizes them, except for final block which doesn't have a summary at the end)
        const blocks = [];
        let currentBlock = [];
        currentBlock.globalMessageIndices = [];
        for(let m of thisLevelAndPreviousLevelMessageObjs) {
          currentBlock.push(m.text);
          currentBlock.globalMessageIndices.push(m.index); // this is for use in determining summary injection/placement
          if(m.level === summaryLevelBeingProcessed) {
            blocks.push(currentBlock);
            currentBlock = [];
            currentBlock.globalMessageIndices = [];
          }
        }
        if(summaryLevelBeingProcessed === 1 && currentBlock.length === 0) {
          console.warn("final block for summaryLevel==1 should have messages? if it doesn't, then we're maybe summarizing too close to the end of the chat log?");
        }
        blocks.push(currentBlock); // final block doesn't have a summary at the end
        summaryLevelToMessageBlocks.set(summaryLevelBeingProcessed, blocks);
        
        summaryLevelBeingProcessed++;
      }
      
      const summaryLevelBlockEntries = [...summaryLevelToMessageBlocks.entries()].sort((a,b) => a[0]-b[0]); // ascending order
      for(let [summaryLevel, blocks] of summaryLevelBlockEntries) {
        
        // note: a block is just an array of messages, and all of them have a summary message (i.e. higher-level message) at the end EXCEPT the last block - we're in the process of adding that summary message here.
        // but also note: the block has a globalMessageIndices property which is also an array (see above)
        let messagesToSummarizeFromFinalBlock = blocks[blocks.length-1];
        
        // note that we can use numCharsToSummarizeAtATime here even for the first level without worrying about summarizing too close to the end of the chat because we have a currentlyUsedContextLength check before running this summarization process.
        let numCharsInFinalBlock = messagesToSummarizeFromFinalBlock.reduce((a,v) => a+v.length, 0);
        if(numCharsInFinalBlock < numCharsToSummarizeAtATime) { 
          console.log(`summaryLevel=${summaryLevel} doesn't need summarizing yet. numCharsInFinalBlock=${numCharsInFinalBlock}`);
          continue;
        }
      
        // remove messages from last block (which contains all messages after the last summary) until it's a good size for summarization:
        while(1) {
          if(messagesToSummarizeFromFinalBlock.length <= 2) break;
          let numChars = messagesToSummarizeFromFinalBlock.reduce((a,v) => a+v.length, 0);
          if(numChars < numCharsToSummarizeAtATime) break;
          
          // to speed things up, drop latter half if it's way too big:
          if(numChars > numCharsToSummarizeAtATime*10) {
            let halfOfMessagesCount = Math.floor(messagesToSummarizeFromFinalBlock.length/2);
            for(let j = 0; j < halfOfMessagesCount; j++) {
              messagesToSummarizeFromFinalBlock.pop();
              messagesToSummarizeFromFinalBlock.globalMessageIndices.pop();
            }
          }
          
          messagesToSummarizeFromFinalBlock.pop();
          messagesToSummarizeFromFinalBlock.globalMessageIndices.pop(); // this is an array of indices aligned with the messages array, for detemining summary injection location
        }

        if(messagesToSummarizeFromFinalBlock.length === 0) {
          console.error("No messages to summarize??");
          continue;
        }

        let existingSummary = window.summariesReadyToInject.filter(s => s.summarizedMessages.join("\n\n") === messagesToSummarizeFromFinalBlock.join("\n\n"))[0];
        if(existingSummary) {
          console.error("Existing summary hasn't been injected yet?? Should have happened before this code ran.");
          return;
        }
        
        // Note: It may seem brittle to choose an *index* to inject the summary at, but we also check to ensure the previous message matches.
        // And if the text has since been edited, that's fine - the summary just gets thrown away and we re-do it next time the send button is clicked.
        let lastMessageSummarizedIndex = messagesToSummarizeFromFinalBlock.globalMessageIndices[messagesToSummarizeFromFinalBlock.length-1];
        if(messagesToSummarizeFromFinalBlock.globalMessageIndices.length !== messagesToSummarizeFromFinalBlock.length) { console.error("should be one index per message"); return; }
        
        let exampleBlocksForStartWith = blocks.slice(-3, -1);
        let exampleBlockSummaries = exampleBlocksForStartWith.map(b => b[b.length-1]);
        
        // we get all messages for this summary level and above for placement in instruction (i.e. as context to help with summarization):
        let instructionSummaries = getMessagesWithSummaryReplacements(storySoFarElText, {minimumMessageLevel:summaryLevel});
        
        // note that we can't just remove the last two instruction summaries here - they aren't necessarily the same as the summaries from the `exampleBlocksForStartWith` because they may have been 'compressed' into a higher level, so there can actually be no overlap at all.
        // so we need to pop the instructionSummaries off based on the ones that are actually in the example blocks:
        while(1) {
          if(instructionSummaries.length === 0) break;
          if(exampleBlockSummaries.includes(instructionSummaries[instructionSummaries.length-1])) {
            instructionSummaries.pop();
            continue;
          }
          break;
        }
        instructionSummaries = instructionSummaries.map(m => m.replace(/SUMMARY\^[0-9]+:/, "").trim());
        
        let startWithBlocks = exampleBlocksForStartWith.map((block) => ({messages:block.slice(0, -1), summary:block.slice(-1)[0]}));
        startWithBlocks.push({messages:messagesToSummarizeFromFinalBlock, summary:""});
        
        if(messagesToSummarizeFromFinalBlock.join("\n").replaceAll(`SUMMARY^${summaryLevel-1}:`, "").includes("SUMMARY^")) {
          console.error("Should have only been summaryLevel-1 summaries in messagesToSummarizeText. messagesToSummarizeFromFinalBlock:", messagesToSummarizeFromFinalBlock);
        }
        
        let startWith = startWithBlocks.map(({messages, summary}, blockI) => {
          let letterLabel = "";
          if(blockI===0) letterLabel = "[A]";
          if(blockI===1) letterLabel = "[B]";
          if(blockI===2) letterLabel = "[C]";

          let messagesText = messages.map((message, mi) => {
            message = message.replace(`SUMMARY\^${summaryLevel-1}:`, "").replace(`SUMMARY\^${summaryLevel}:`, "").replace(/\n/g, " ").trim();
            return `${summaryLevel === 1 ? `(${mi+1}) ` : ""}${message}`; // we prefix bottom-level messages with numbers, but not SUMMARY^N messages.
          }).join(" ");
          
          summary = summary.replace(`SUMMARY\^${summaryLevel-1}:`, "").replace(`SUMMARY\^${summaryLevel}:`, "").replace(/\n/g, " ").trim();

          return `${letterLabel} ${messagesText}\nSUMMARY of ${letterLabel}: ${summary}`;
        }).join("\n\n");
        
        // since possible for there to be no blocks before the messages to summarize
        startWith = startWith.trim(); // this is also important to prevent whitespace at end of startWith

        window.summaryMessagesForInstruction = instructionSummaries.length > 0 ? instructionSummaries : ["(None.)"]; // used in summaryPromptInstruction
        let instruction = root.summaryPromptInstruction.evaluateItem;
        window.summaryMessagesForInstruction = null;

        let promptOptions = {
          instruction,
          startWith,
          stopSequences: ["\n\n"],
        };

        let data = await root.ai(promptOptions);
        
        if(data.stopReason === "error") continue; // could retry a few times, but this is no big deal, since every message sent triggers another attempt
        
        let summary = data.generatedText.trim().replace(/\n+/g, " ");
        if((instructionSummaries[instructionSummaries.length-1] || "").trim() === summary.trim()) {
          // AI has copied the previous summary, which sometimes happens.
          console.warn("AI copied previous summary. Skipping this summary level for this 'round'.");
          continue;
        }
        
        console.log("----------------");
        console.log("----------------");
        console.log("----------------");
        console.log("ùóüùóòùó©ùóòùóü:", summaryLevel);
        console.log("ùóúùó°ùó¶ùóßùó•ùó®ùóñùóßùóúùó¢ùó°:", instruction);
        console.log("ùó¶ùóßùóîùó•ùóßùó™ùóúùóßùóõ:", startWith);
        console.log("ùó¶ùó®ùó†ùó†ùóîùó•ùó¨:", summary);
        console.log("----------------");
        console.log("----------------");
        console.log("----------------");
        
        window.summariesReadyToInject.push({summarizedMessages:messagesToSummarizeFromFinalBlock, lastMessageSummarizedIndex, summary, level:summaryLevel});
      }
    } catch(e) {
      console.error(e);
    } finally {
      window.alreadyDoingSummary = false;
    }
  })();

async confirmAsync(message, opts) =>
  if(!opts) opts = {};
  if(!message) message = "Are you sure?"
  return new Promise(resolve => {
    const overlay = Object.assign(document.createElement("div"), { tabIndex: 0 });
    overlay.style.cssText = `position:fixed;inset:0;z-index:99999999;display:grid;place-items:center;background-color:rgba(0,0,0,.65);font:16px/1.4 system-ui`;
    overlay.innerHTML = `<div style="text-align:left !important;max-width:min(97vw, 450px);padding:15px;border-radius:8px;background-color:light-dark(#fff,#222);color:light-dark(#000,#fff);box-shadow:0 2px 8px rgba(0,0,0,.2);">
      <p style="margin:0 0 20px;white-space:pre-wrap;">${message.replace(/[<>&]/g, m => ({"<":"&lt;","&":"&amp;",">":"&gt;"}[m]))}</p>
      <div style="display:flex;justify-content:flex-end;gap:8px;">
        <button ${opts.hideCancel ? "hidden" : ""} style="padding:6px 16px;border:1px solid light-dark(#ccc,#555);border-radius:6px;background-color:light-dark(#f6f6f6,#333);color:inherit;cursor:pointer;">Cancel</button>
        <button autofocus style="padding:6px 16px;border:none;border-radius:6px;background-color:light-dark(#1677ff,#2b87ff);color:#fff;cursor:pointer;">Okay</button>
      </div>
    </div>`;
    const [cancelBtn, okBtn] = overlay.querySelectorAll("button");
    const finish = val => { overlay.remove(); resolve(val); };
    cancelBtn.onclick = () => finish(false);
    okBtn.onclick = () => finish(true);
    overlay.onkeydown = e => {
      if (e.key === "Escape") finish(false);
      else if (e.key === "Enter") finish(true);
    };
    document.body.append(overlay);
    overlay.focus({ preventScroll: true }); // enables Esc handling immediately
  });
  
async loadDataFromUrlHash() => 
  let success = false;
  if(!window.DecompressionStream) {
    alert("Story share links use a browser feature that's only available in modern browsers. Please upgrade your browser to the latest version to allow for loading data from story share links.");
    return {success, error:"browser_compat"};
  }
  
  let loadingModal = document.createElement('div');
  loadingModal.innerHTML = `<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 9999; display: flex; justify-content: center; align-items: center;">
    <div style="padding: 20px; background-color: var(--box-color); border-radius: 8px;">
      ‚è≥ loading story data...
    </div>
  </div>`;
  loadingModal = loadingModal.firstElementChild;
  document.body.append(loadingModal);
  
  try {
    let hashText = window.location.hash.slice(1);
    if(!hashText.startsWith("data=")) {
      throw new Error("Invalid share URL.");
    }
    let fileUrl = hashText.replace(/^data=/, "");
    if(fileUrl.startsWith("uup1:")) {
      fileUrl = fileUrl.replace("uup1:", "https://user-uploads.perchance.org/file/");
    }
    let fetchOptions = {};
    if(window.AbortSignal && AbortSignal.timeout) fetchOptions.signal = AbortSignal.timeout(10000);
    let blob = await fetch(fileUrl, fetchOptions).then(res => res.ok ? res.blob() : null).catch(console.error);
    if(!blob) {
      loadingModal.remove();
      await confirmAsync(`It seems you've tried to load a share URL, but the file specified by the URL does not exist. If you believe it should exist, you can ask for help on the community forum, or check if the file has been quarantined:\n\nperchance.org/quarantined-files`, {hideCancel:true});
      return {success:false, error:"loading_cancelled_by_user"};
    }
    let text;
    if(fileUrl.endsWith(".gz")) {
      let decompressedBlob = await decompressBlobWithGzip(blob);
      text = await decompressedBlob.text();
    } else {
      text = await blob.text();
    }
    let data = JSON.parse(text);
    if(data.format === "perchance-ai-story-v1") {
      let confirmed = await confirmAsync("ùóõùó≤ùóÆùó±ùòÄ ùòÇùóΩ: You're loading a story share link. This will overwrite your existing story data. ùóñùóºùóªùòÅùó∂ùóªùòÇùó≤?\n\n(Note: You can click cancel and then load the share link in your browser's incognito/private mode to avoid overwriting your current story, or just save your existing story first.)");
      if(!confirmed) {
        window.location.hash = "";
        loadingModal.remove();
        return {success, error:"loading_cancelled_by_user"};
      }
      // if((storyOverviewEl.value+storySoFarEl.value+whatHappensNextEl.value).trim() !== "") { }
      try { loadDataIntoLocalStorage(data); } catch(e) { alert("Failed to load data into your browser storage. Please report this issue using the feedback button, including the story length (word count) and your device/browser."); console.error(e); }
      loadChatDataIntoInputAreas(data);
      success = true;
    } else {
      alert("Unknown story data format.");
    }
  } catch(e) {
    alert(`Failed to load story data: ${e.message}`);
    console.error(e);
  }
  
  loadingModal.remove();
  return {success};
  
async decompressBlobWithGzip(blob) =>
  const ds = new DecompressionStream("gzip");
  const decompressedStream = blob.stream().pipeThrough(ds);
  return await new Response(decompressedStream).blob();

getCurrentStoryData() =>
  return {
    format: "perchance-ai-story-v1",
    storyOverview: storyOverviewEl.value.trim(),
    storySoFar: storySoFarEl.value.trim(),
    whatHappensNext: whatHappensNextEl.value.trim(),
    oneParagraphAtATime: oneParagraphAtATimeCheckbox.checked,
  };

saveStoryDataToUsersDevice() => 
  let data = getCurrentStoryData();
  let filename = prompt("Choose a filename:", window.lastSaveFilenameUsed || "my-story");
  if(filename === null) return;
  window.lastSaveFilenameUsed = filename;
  filename += ".ai-story.json";
  let blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  let url = URL.createObjectURL(blob);
  let a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
  
async loadStoryDataFromUsersDevice() =>
  return new Promise((resolve, reject) => {
    let input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json, text/json, text/plain, application/JSON, .json';
    input.onchange = async (event) => {
      let file = event.target.files[0];
      if (file) {
        try {
          let content = await file.text();
          let data = JSON.parse(content);
          if(data.format === "perchance-ai-story-v1") {
            if((storyOverviewEl.value+storySoFarEl.value+whatHappensNextEl.value).trim() !== "") {
              let confirmed = confirm("Loading this data will ùóºùòÉùó≤ùóøùòÑùóøùó∂ùòÅùó≤ your current story. Continue?");
              if(!confirmed) return;
            }
            try { loadDataIntoLocalStorage(data); } catch(e) { alert("Failed to load data into your browser storage. Please report this issue using the feedback button, including the story length (word count) and your device/browser."); console.error(e); }
            loadChatDataIntoInputAreas(data);
          } else {
            alert("Unknown save file format.");
          }
        } catch (error) {
          alert("There was an error while loading that story file.");
          reject(error);
        }
      }
    };
    input.click();
  });




//üéÉüéÉ

